<!DOCTYPE html>
<html lang="en">
  <!-- Head tag -->
  <head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <!-- Title -->
  
  <title>A Voxel PathTracing Engine - Jiayu He</title>

  <!--Favicon-->
  <link rel="icon" href="favicon/favicon.ico">

  <!--Description-->
  
      <meta name="description" content="A PathTracing Voxel Engine implemented from Godot and Vulkan.">
  

  <!--Author-->
  
      <meta name="author" content="Jiayu He">
  

  <!-- Pure CSS -->
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.6/css/bootstrap.min.css" integrity="sha384-rwoIResjU2yc3z8GV/NPeZWAv56rSmLldC3R/AZzGRnGxQQKnKkoFVhFQhNUwEyJ" crossorigin="anonymous">
  <link href="https://fonts.googleapis.com/css?family=Crimson+Text|Open+Sans:300,800" rel="stylesheet">

  <!-- Custom CSS -->
  
<link rel="stylesheet" href="/css/styles.css">


  <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
  <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
  <![endif]-->

  <!-- Google Analytics -->
  

<meta name="generator" content="Hexo 6.3.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>




  <body>
  	<!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container-fluid navbar-container m-sm-5">
      <!-- Header -->
      <nav class="navbar navbar-toggleable-sm navbar-light px-1 py-3 my-3 mb-sm-5">
  <a class="navbar-brand ml-2" href="/">Jiayu He</a>
  <button class="navbar-toggler navbar-toggler-right py-2" type="button" data-toggle="collapse" data-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>
  <div class="collapse navbar-collapse text-center" id="navbarCollapse">
    <ul class="navbar-nav ml-auto my-auto">
      
        <li class="nav-item">
          <a class="nav-link" href="/reel">Reel</a>
        </li>
      
        <li class="nav-item">
          <a class="nav-link" href="/about">About</a>
        </li>
      
        <li class="nav-item">
          <a class="nav-link" href="/contact">Contact</a>
        </li>
      
        <li class="nav-item">
          <a class="nav-link" target="_blank" rel="noopener" href="https://www.instagram.com/jiayuhe511/">Instagram</a>
        </li>
      
        <li class="nav-item">
          <a class="nav-link" target="_blank" rel="noopener" href="https://www.linkedin.com/in/jiayu-he-389213145/">LinkedIn</a>
        </li>
      
    </ul>
    <hr class="hidden-md-up" />
  </div>
</nav>

  		<div class="row">
  			<div class="col-lg-4 col-12 pt-3 px-4 pr-lg-5">
  <h1>A Voxel PathTracing Engine</h1>
</div>
<div class="col-lg-8 col-12 pt-lg-3 mb-4 pl-lg-5 px-lg-0 px-4 portfolio-content">
  <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h1 id="A-Voxel-PathTracing-Engine"><a href="#A-Voxel-PathTracing-Engine" class="headerlink" title="A Voxel PathTracing Engine"></a>A Voxel PathTracing Engine</h1><h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>This is a project that is still in development. </p>
<p>I’ve had the plan to create a voxel engine for a long time. For me, voxel has many advantages, such as being easy to implement path tracing, ambient occlusion (VXAO), and global illumination (VXGI). It is well-suited for physical simulations like simulating smoke, and it’s great for quantifying the size of artistic resources while achieving a unified style.</p>
<p>So, I’ve always been curious about whether an excellent voxel engine can cover all these advantages. Therefore, on the last weekend of 2023, I started the development of a voxel engine. At the same time, I happened to be studying the source code of the Godot engine, so I decided to start with Godot.</p>
<p><a href="image-20240110013800500.png" class="gallery-item"><img src="image-20240110013800500.png" alt=""></a></p>
<h2 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h2><p>I referred to the technical discussions of Teardown, where a large number of technical details are introduced. Firstly, Teardown uses the texture3D method for voxel storage. Teardown mainly focuses on object space-aligned voxels, and its rendering pipeline is not much different from ordinary deferred rendering. It stores a <strong>Gbuffer</strong> primarily for normal PBR rendering. The calculations for AO and reflection are done by sampling a world-space aligned voxel.</p>
<p><a href="image-20240110004055181.png" title="Architecture in TearDown" class="gallery-item"><img src="image-20240110004055181.png" alt="Architecture in TearDown"></a></p>
<p>On the contrary, I want to try a more global rendering algorithm. I plan to organize all voxels, meshes, and rigged meshes into a large world-space aligned voxel using compute shaders. Here, I will perform unified rendering and physics calculations. This approach has many advantages. Firstly, I can directly obtain global depth, normal, and material information. I don’t need to store them in advance. I can even complete ray tracing, PBR shading, and denoising (TAA) in a single pass. The Gbuffer in Teardown is a very significant overhead.</p>
<p>The specific architecture of my project is as follows:</p>
<p><a href="image-20240110003634006.png" title="My architecture" class="gallery-item"><img src="image-20240110003634006.png" alt="My architecture"></a></p>
<h2 id="Rendering"><a href="#Rendering" class="headerlink" title="Rendering"></a>Rendering</h2><p>Assuming we already have a world-space aligned Texture 3D, how should we go about path tracing? First, I bind a shader to a TextureRect with the same resolution as the camera. This fragment shader will simulate rays emanating from the camera’s frustum into the outside world.</p>
<p>Firstly, we can perform an AABB check. Rays that extend beyond the boundaries of the voxel bounding box are not considered. For AABB detection, you can refer to my previous articles, similar to BVH collision.</p>
<p>After completing the AABB check, we obtain the entry points of each ray for box collisions. From these entry points, we perform ray marching within the voxel field. I implemented this paper, which excellently explains how to perform ray marching using only 33 float points calculations. Specifically, ray marching involves continuously stepping along the ray’s direction and sampling this 3D texture with the new coordinates. The order in the condition below should be: 0 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4. How do we derive this order?</p>
<p>We first calculate two crucial times for the ray:</p>
<ol>
<li>The time it takes for the ray to collide with the next boundary along each axis, known as <strong>t_max</strong>. By comparing t_max for each axis, we can determine which axis the ray will collide with first, indicating the direction in which we need to step earliest.</li>
<li>The time it takes for the ray to step to the unit voxel along each axis (<strong>t_step</strong>). This time is a constant value because the length of each step is consistent, and the ray’s direction is also consistent. Storing this value allows us to quickly update <strong>t_max</strong> after each step. Thus, after each step, we don’t need to re-solve t_max by dividing the distance by the speed. We only need to add the newly spent <strong>t_step</strong>.</li>
</ol>
<p><a href="image-20240110012023818.png" title="raymarching" class="gallery-item"><img src="image-20240110012023818.png" alt="raymarching"></a></p>
<p>Once you understand this, you’ll find that the efficiency of voxel sampling is very high. I’m placing the code here for reference.</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">recordVolume raymarchVolume(ray r, inout recordVolume rec, box volumeAABB){
    rec.hit = false;
    int stepX = r.direction.x &gt; 0.0f? 1 : -1;
    int stepY = r.direction.y &gt; 0.0f? 1 : -1;
    int stepZ = r.direction.z &gt; 0.0f? 1 : -1;
    float tDeltaX = abs((_volumeSize/float(_volumeGrid.x))/r.direction.x);
    float tDeltaY = abs((_volumeSize/float(_volumeGrid.y))/r.direction.y);
    float tDeltaZ = abs((_volumeSize/float(_volumeGrid.z))/r.direction.z);
    vec3 pos= r.origin + r.direction * rec.t;
    int X = int(floor(pos.x /_volumeSize * _volumeGrid.x));
    int Y = int(floor(pos.y /_volumeSize * _volumeGrid.y));
    int Z = int(floor(pos.z /_volumeSize * _volumeGrid.z));
    if( X == int(_volumeGrid.x)) X-= 1;
    if( Y == int(_volumeGrid.y)) Y-= 1;
    if( Z == int(_volumeGrid.z)) Z-= 1;
    int nextX = r.direction.x &gt; 0.0f? 1 : 0;
    int nextY = r.direction.y &gt; 0.0f? 1 : 0;
    int nextZ = r.direction.z &gt; 0.0f? 1 : 0;

    vec3 nextPos = getPosbyIndex(X+nextX, Y+nextY, Z+nextZ);
    float tMaxX = (nextPos.x - pos.x)/r.direction.x;
    float tMaxY = (nextPos.y - pos.y)/r.direction.y;
    float tMaxZ = (nextPos.z - pos.z)/r.direction.z;
    float potentialTime = 0.0f; //record the hit intervel traveling time
    vec3 potentialNormal = rec.normal;//record the hit normal
    //if hit on the bounding box , then just sample and return
    if(sample3D(X,Y,Z).a&gt; _alphaClip){
            rec.color =sample3D(X,Y,Z).rgb;
            rec.hit = true;
            rec.position = r.origin + r.direction*(rec.t);
            rec.normal = potentialNormal;
            return rec;
    }
    //if didn't hit on surface, then do the raymarching.
    while(!rec.hit){
        if(tMaxX &lt; tMaxY){
            if(tMaxX &lt; tMaxZ){
                X+=stepX;
                potentialTime = tMaxX;
                if((X &gt;= int(_volumeGrid.x))|| (X &lt; 0)) {
                    break;
                }

                tMaxX += tDeltaX;
                potentialNormal = vec3(-float(stepX), 0,0);
            }else{
                Z += stepZ;
                potentialTime = tMaxZ;
                if((Z&lt;0)||(Z &gt;= int(_volumeGrid.z))){
                    break;
                }
                tMaxZ += tDeltaZ;
                potentialNormal = vec3(0,0, -float(stepZ));
            }
        }else{
            if(tMaxY &lt; tMaxZ){
                Y+=stepY;
                potentialTime = tMaxY;
                if((Y &gt;= int(_volumeGrid.y))|| (Y &lt; 0)) {
                    break;
                }
                tMaxY += tDeltaY;
                potentialNormal = vec3(0,-float(stepY),0);
            }else{
                Z += stepZ;
                potentialTime = tMaxZ;
                if((Z&lt;0)||(Z &gt;= int(_volumeGrid.z))){
                    break;
                }
                tMaxZ += tDeltaZ;
                potentialNormal = vec3(0,0, -float(stepZ));
            }
        }
        if(sample3D(X,Y,Z).a&gt; _alphaClip){
            rec.color = sample3D(X,Y,Z).rgb;
            rec.hit = true;
            rec.normal = potentialNormal;
            rec.position = r.origin + r.direction*(rec.t + potentialTime);
            break;
        }

    }
	return rec;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="Results"><a href="#Results" class="headerlink" title="Results"></a>Results</h2><p><a href="image-20240110013258584.png" class="gallery-item"><img src="image-20240110013258584.png" alt=""></a></p>
<p><a href="image-20240110013127094.png" class="gallery-item"><img src="image-20240110013127094.png" alt=""></a></p>
</div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script src="https://github.com/sachinchoolur/lg-thumbnail.js"></script><script src="https://github.com/sachinchoolur/lg-zoom.js"></script><script src="https://github.com/sachinchoolur/lg-autoplay.js"></script><script src="https://github.com/sachinchoolur/lg-fullscreen.js"></script><script src="https://github.com/sachinchoolur/lg-pager.js"></script><script src="https://github.com/sachinchoolur/lg-video.js"></script><script src="https://github.com/sachinchoolur/lg-hash.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script>
</div>


      </div>
      
  	</div>

    <!-- After footer scripts -->
    <script src="https://code.jquery.com/jquery-3.1.1.slim.min.js" integrity="sha384-A7FZj7v+d/sdmMqp/nOQwliLvUsJfDHW+k9Omg/a/EheAdgtzNs3hpfag6Ed950n" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tether/1.4.0/js/tether.min.js" integrity="sha384-DztdAPBWPRXSA/3eYEEUWrWCy7G5KFbe8fFjk5JAIxUYHKkDx6Qin1DkWx51bBrb" crossorigin="anonymous"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.6/js/bootstrap.min.js" integrity="sha384-vBWWzlZJ8ea9aCX4pEW3rVHjgjt7zpkNpZk+02D9phzyeVkE+jo0ieGizqPLForn" crossorigin="anonymous"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

  </body>
</html>
